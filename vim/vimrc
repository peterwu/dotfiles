" let the fun begin

" commons {{{

const s:vim_home = expand('<sfile>:p:h')

" modus operandi color palette
const s:palette = {
            "\ Basic values
            \  'bg_main':            "#ffffff",
            \  'bg_dim':             "#f0f0f0",
            \  'fg_main':            "#000000",
            \  'fg_dim':             "#595959",
            \  'fg_alt':             "#193668",
            \  'bg_active':          "#c4c4c4",
            \  'bg_inactive':        "#e0e0e0",
            \  'border':             "#9f9f9f",
            \
            "\ Common accent foregrounds
            \  'red':                "#a60000",
            \  'red_warmer':         "#972500",
            \  'red_cooler':         "#a0132f",
            \  'red_faint':          "#7f0000",
            \  'red_intense':        "#d00000",
            \  'green':              "#006800",
            \  'green_warmer':       "#316500",
            \  'green_cooler':       "#00663f",
            \  'green_faint':        "#2a5045",
            \  'green_intense':      "#008900",
            \  'yellow':             "#6f5500",
            \  'yellow_warmer':      "#884900",
            \  'yellow_cooler':      "#7a4f2f",
            \  'yellow_faint':       "#624416",
            \  'yellow_intense':     "#808000",
            \  'blue':               "#0031a9",
            \  'blue_warmer':        "#3548cf",
            \  'blue_cooler':        "#0000b0",
            \  'blue_faint':         "#003497",
            \  'blue_intense':       "#0000ff",
            \  'magenta':            "#721045",
            \  'magenta_warmer':     "#8f0075",
            \  'magenta_cooler':     "#531ab6",
            \  'magenta_faint':      "#7c318f",
            \  'magenta_intense':    "#dd22dd",
            \  'cyan':               "#005e8b",
            \  'cyan_warmer':        "#3f578f",
            \  'cyan_cooler':        "#005f5f",
            \  'cyan_faint':         "#005077",
            \  'cyan_intense':       "#008899",
            \
            "\ Uncommon accent foregrounds
            \  'rust':               "#8a290f",
            \  'gold':               "#80601f",
            \  'olive':              "#56692d",
            \  'slate':              "#2f3f83",
            \  'indigo':             "#4a3a8a",
            \  'maroon':             "#731c52",
            \  'pink':               "#7b435c",
            \
            "\ Common accent backgrounds
            \  'bg_red_intense':     "#ff8f88",
            \  'bg_green_intense':   "#8adf80",
            \  'bg_yellow_intense':  "#f3d000",
            \  'bg_blue_intense':    "#bfc9ff",
            \  'bg_magenta_intense': "#dfa0f0",
            \  'bg_cyan_intense':    "#a4d5f9",
            \
            \  'bg_red_subtle':      "#ffcfbf",
            \  'bg_green_subtle':    "#b3fabf",
            \  'bg_yellow_subtle':   "#fff576",
            \  'bg_blue_subtle':     "#ccdfff",
            \  'bg_magenta_subtle':  "#ffddff",
            \  'bg_cyan_subtle':     "#bfefff",
            \
            \  'bg_red_nuanced':     "#fff1f0",
            \  'bg_green_nuanced':   "#ecf7ed",
            \  'bg_yellow_nuanced':  "#fff3da",
            \  'bg_blue_nuanced':    "#f3f3ff",
            \  'bg_magenta_nuanced': "#fdf0ff",
            \  'bg_cyan_nuanced':    "#ebf6fa",
            \
            "\ Uncommon accent backgrounds
            \  'bg_ochre':           "#f0e0cc",
            \  'bg_lavender':        "#dfdbfa",
            \  'bg_sage':            "#c0e7d4"
            \ }

function! s:highlight(group, fg, bg, style) abort
    let l:cmd = 'highlight ' .. a:group
                \ .. ' guifg=' .. a:fg
                \ .. ' guibg=' .. a:bg
                \ .. ' gui='   .. a:style
                \ .. ' cterm=' .. a:style
    execute l:cmd
endfunction

" }}}

" options {{{

" --------
" defaults
" --------
source $VIMRUNTIME/defaults.vim

" ---------
" work dirs
" ---------
call mkdir(s:vim_home .. '/backup', 'p', 0o700)
call mkdir(s:vim_home .. '/cache',  'p', 0o700)
call mkdir(s:vim_home .. '/swap',   'p', 0o700)
call mkdir(s:vim_home .. '/undo',   'p', 0o700)
call mkdir(s:vim_home .. '/view',   'p', 0o700)

" -------
" options
" -------
set autoindent
set autoread
let &backupdir=s:vim_home .. '/backup'
set background=light
set complete-=i
set completeopt=menu,menuone,noinsert,noselect
set cursorline
let &directory=s:vim_home .. '/swap'
set encoding=utf-8
set expandtab
set fileformats=unix,dos,mac
set foldmethod=marker
set formatoptions=tcqj
set hidden
set history=1000
set hlsearch
set ignorecase
set laststatus=2
set lazyredraw
set listchars=trail:·,tab:»·
set mouse=a
set mousemodel=popup_setpos
set nolist
set noshowmode
set notitle
set number
set path+=**
set pumheight=7
set relativenumber
set scrolloff=1
set sessionoptions-=options
set shiftround
set shiftwidth=4
set shortmess+=Ic
set showmatch
set sidescroll=1
set sidescrolloff=2
set smartcase
set smartindent
set smarttab
set softtabstop=0
set splitbelow
set splitright
set switchbuf=uselast
set tabstop=8
set termencoding=utf-8
set termguicolors
set timeoutlen=777
set ttimeoutlen=77
let &undodir=s:vim_home .. '/undo'
set undofile
let &viewdir=s:vim_home .. '/view'
set viewoptions=cursor,folds
set viminfo=%,<800,'10,/50,:100,h,f0
let &viminfofile=s:vim_home .. '/cache/viminfo'
set virtualedit=block
set wildoptions=pum,tagfile

colorscheme lunaperche

" }}}

" keymaps {{{

" ------------
" key mappings
" ------------
" leaders
let g:mapleader      = " "
let g:maplocalleader = ","

" vimrc
nnoremap <silent> <Leader>cd <Cmd>cd     %:p:h<CR><Cmd>pwd<CR>
nnoremap <silent> <Leader>ev <Cmd>edit   $MYVIMRC<CR>
nnoremap <silent> <Leader>sv <Cmd>source $MYVIMRC<CR>

" disable arrow keys
noremap <Up>    <Nop>
noremap <Down>  <Nop>
noremap <Left>  <Nop>
noremap <Right> <Nop>

inoremap <Up>    <Nop>
inoremap <Down>  <Nop>
inoremap <Left>  <Nop>
inoremap <Right> <Nop>

" use arrow keys to navigate windows
nnoremap <Up>    <Cmd>wincmd<Space>k<CR>
nnoremap <Down>  <Cmd>wincmd<Space>j<CR>
nnoremap <Left>  <Cmd>wincmd<Space>h<CR>
nnoremap <Right> <Cmd>wincmd<Space>l<CR>

" use alt+arrow keys to navigate tabs
nnoremap <A-Up>    <Cmd>silent! tabnext<Space>$<CR>
nnoremap <A-Down>  <Cmd>silent! tabnext<Space>1<CR>
nnoremap <A-Left>  <Cmd>silent! tabnext<Space>-<CR>
nnoremap <A-Right> <Cmd>silent! tabnext<Space>+<CR>

" use alt+{num} to switch to tab #{num}
nnoremap <A-1> <Cmd>silent! tabnext<Space>1<CR>
nnoremap <A-2> <Cmd>silent! tabnext<Space>2<CR>
nnoremap <A-3> <Cmd>silent! tabnext<Space>3<CR>
nnoremap <A-4> <Cmd>silent! tabnext<Space>4<CR>
nnoremap <A-5> <Cmd>silent! tabnext<Space>5<CR>
nnoremap <A-6> <Cmd>silent! tabnext<Space>6<CR>
nnoremap <A-7> <Cmd>silent! tabnext<Space>7<CR>
nnoremap <A-8> <Cmd>silent! tabnext<Space>8<CR>
nnoremap <A-9> <Cmd>silent! tabnext<Space>9<CR>

" swap j/k <-> gj/gk
nnoremap <expr> j (v:count ? 'j' : 'gj')
nnoremap <expr> k (v:count ? 'k' : 'gk')
xnoremap <expr> j (v:count ? 'j' : 'gj')
xnoremap <expr> k (v:count ? 'k' : 'gk')

" use tab to select from popup menu
inoremap <expr> <Tab>   (pumvisible() ? '<C-N>' : '<Tab>')
inoremap <expr> <S-Tab> (pumvisible() ? '<C-P>' : '<C-H>')

" use tab to toggle folds
nnoremap <Tab> za

" stolen from neovim defaults
nnoremap Y     yg_
nnoremap <C-L> <Cmd>nohlsearch<Bar>diffupdate<Bar>normal! <C-L><CR>
inoremap <C-U> <C-G>u<C-U>
inoremap <C-W> <C-G>u<C-W>
xnoremap *     y/\V<C-R>"<CR>
xnoremap #     y?\V<C-R>"<CR>
nnoremap &     <Cmd>&&<CR>

" copy to clipboard
if has('clipboard')
    vnoremap <silent> <Leader>y  "+y
    nnoremap <silent> <Leader>y  "+y
    nnoremap <silent> <Leader>Y  "+yg_
    nnoremap <silent> <Leader>yy "+y_
elseif executable('/usr/bin/xsel')
    vnoremap <silent> <Leader>y  <Cmd>set operatorfunc=<SID>copy_to_clipboard<CR>g@
    nnoremap <silent> <Leader>y  <Cmd>set operatorfunc=<SID>copy_to_clipboard<CR>g@
    nnoremap <silent> <Leader>Y  <Cmd>set operatorfunc=<SID>copy_to_clipboard<CR>g@g_
    nnoremap <silent> <Leader>yy <Cmd>set operatorfunc=<SID>copy_to_clipboard<CR>g@_

    function! s:copy_to_clipboard(type, ...) abort
        let l:reg = '"'
        let l:sel_save = &selection
        let &selection = "inclusive"
        let l:cb_save  = &clipboard
        let l:reg_save = getreg(reg)
        let l:reg_type = getregtype(reg)

        if a:type ==# "char"
            silent! execute 'normal! v`[o`]"' .. l:reg .. 'y'
        elseif a:type ==# "line"
            silent! execute 'normal! `[V`]"' .. l:reg .. 'y'
        elseif a:type ==# "v" || a:type ==# "V" || a:type ==# "\<C-V>" || a:type ==# "block"
            let &selection = l:sel_save
            let l:ve = &virtualedit

            if !(a:0 && a:1)
                set virtualedit=none
            endif

            silent execute 'normal! gv"' .. l:reg .. 'y'
            let &virtualedit = l:ve
        elseif a:type =~ '^\d\+$'
            silent! execute 'normal! ^v' .. a:type .. '$h"' .. l:reg .. 'y'
            if mode() ==# 'v'
                normal! v
            endif
        else
            let &selection = l:sel_save
            let &clipboard = l:cb_save
        endif

        silent! call system('/usr/bin/xsel -i -b -l /dev/null', getreg(l:reg))

        call setreg(l:reg, l:reg_save, l:reg_type)
        let &selection = l:sel_save
        let &clipboard = l:cb_save
    endfunction
endif

" paste from clipboard
if has('clipboard')
    nnoremap <silent> <Leader>p "+p
    nnoremap <silent> <Leader>P "+P
    vnoremap <silent> <Leader>p "+p
    vnoremap <silent> <Leader>P "+P
elseif executable('/usr/bin/xsel')
    nnoremap <silent> <Leader>p <Cmd>silent! let @"=system('xsel -o -b -l /dev/null')<CR>""p
    nnoremap <silent> <Leader>P <Cmd>silent! let @"=system('xsel -o -b -l /dev/null')<CR>""P
    vnoremap <silent> <Leader>p <Cmd>silent! let @"=system('xsel -o -b -l /dev/null')<CR>""p
    vnoremap <silent> <Leader>P <Cmd>silent! let @"=system('xsel -o -b -l /dev/null')<CR>""P
endif

" force saving files that otherwise require sudoedit
command! Wsudo execute "silent! write !sudo tee % >/dev/null" <Bar> edit!
nnoremap <Leader>W <Cmd>Wsudo<CR>

" terminal
tnoremap <Esc> <C-\><C-N>
nnoremap <silent> <Leader>tt <Cmd>belowright terminal<CR>
nnoremap <silent> <Leader>tv <Cmd>belowright vertical terminal<CR>
nnoremap <silent> <Leader>tT <Cmd>botright terminal<CR>
nnoremap <silent> <Leader>tV <Cmd>botright vertical terminal<CR>

" }}}

" auto commands {{{

" -------------
" auto commands
" -------------
augroup save_folds | autocmd!
    autocmd BufWinLeave,BufLeave,BufWritePost ?* ++nested silent! mkview!
    autocmd BufWinEnter ?* silent! loadview
augroup END

augroup set_list | autocmd!
    autocmd InsertEnter,InsertLeave * set list!
augroup END

augroup no_number_for_old_term | autocmd!
    autocmd TerminalWinOpen * setlocal nonumber norelativenumber
augroup END

augroup no_trailing_whitespaces | autocmd!
    autocmd BufWritePre * :%s/\s\+$//e
augroup END

" }}}

" status line {{{

function! s:set_highlights() abort
    call s:highlight_git_branch_status()

    call s:highlight('StatusBlank',      s:palette.fg_main, s:palette.bg_blue_nuanced, 'NONE')
    call s:highlight('StatusFileName',   s:palette.fg_main, s:palette.bg_blue_nuanced, 'bold')
    call s:highlight('StatusFileState',  s:palette.maroon,  s:palette.bg_blue_nuanced, 'bold')
    call s:highlight('StatusFileSize',   s:palette.fg_main, s:palette.bg_blue_nuanced, 'NONE')
    call s:highlight('StatusFileFormat', s:palette.fg_main, s:palette.bg_lavender,     'NONE')
    call s:highlight('StatusFileEncode', s:palette.fg_main, s:palette.bg_lavender,     'NONE')
    call s:highlight('StatusPercent',    s:palette.fg_main, s:palette.bg_blue_nuanced, 'NONE')
endfunction

function! s:get_vim_mode() abort
    " :help mode()
    const l:modes = {
                \ 'n'    : { 'abbrev': 'N',  'alias': 'NORMAL',    'color' : s:palette.blue    },
                \ 'no'   : { 'abbrev': 'O',  'alias': 'O·PENDING', 'color' : s:palette.yellow  },
                \ 'nov'  : { 'abbrev': 'O',  'alias': 'O·PENDING', 'color' : s:palette.yellow  },
                \ 'noV'  : { 'abbrev': 'O',  'alias': 'O·PENDING', 'color' : s:palette.yellow  },
                \ 'no' : { 'abbrev': 'O',  'alias': 'O·PENDING', 'color' : s:palette.yellow  },
                \ 'niI'  : { 'abbrev': 'N',  'alias': 'NORMAL',    'color' : s:palette.blue    },
                \ 'niR'  : { 'abbrev': 'N',  'alias': 'NORMAL',    'color' : s:palette.blue    },
                \ 'niV'  : { 'abbrev': 'N',  'alias': 'NORMAL',    'color' : s:palette.blue    },
                \ 'nt'   : { 'abbrev': 'T',  'alias': 'TERM',      'color' : s:palette.fg_main },
                \ 'v'    : { 'abbrev': 'V',  'alias': 'VISUAL',    'color' : s:palette.cyan    },
                \ 'vs'   : { 'abbrev': 'V',  'alias': 'VISUAL',    'color' : s:palette.cyan    },
                \ 'V'    : { 'abbrev': 'Vl', 'alias': 'V·LINE',    'color' : s:palette.cyan    },
                \ 'Vs'   : { 'abbrev': 'Vl', 'alias': 'V·LINE',    'color' : s:palette.cyan    },
                \ ''   : { 'abbrev': 'Vb', 'alias': 'V·BLOCK',   'color' : s:palette.cyan    },
                \ 's'  : { 'abbrev': 'Vb', 'alias': 'V·BLOCK',   'color' : s:palette.cyan    },
                \ 's'    : { 'abbrev': 'S',  'alias': 'SELECT',    'color' : s:palette.blue    },
                \ 'S'    : { 'abbrev': 'Sl', 'alias': 'S·LINE',    'color' : s:palette.blue    },
                \ ''   : { 'abbrev': 'Sb', 'alias': 'S·BLOCK',   'color' : s:palette.blue    },
                \ 'i'    : { 'abbrev': 'I',  'alias': 'INSERT',    'color' : s:palette.rust    },
                \ 'ic'   : { 'abbrev': 'I',  'alias': 'INSERT',    'color' : s:palette.rust    },
                \ 'ix'   : { 'abbrev': 'I',  'alias': 'INSERT',    'color' : s:palette.rust    },
                \ 'R'    : { 'abbrev': 'R',  'alias': 'REPLACE',   'color' : s:palette.red     },
                \ 'Rc'   : { 'abbrev': 'R',  'alias': 'REPLACE',   'color' : s:palette.red     },
                \ 'Rx'   : { 'abbrev': 'R',  'alias': 'REPLACE',   'color' : s:palette.red     },
                \ 'Rv'   : { 'abbrev': 'Vr', 'alias': 'V·REPLACE', 'color' : s:palette.red     },
                \ 'Rvc'  : { 'abbrev': 'Vr', 'alias': 'V·REPLACE', 'color' : s:palette.red     },
                \ 'Rvx'  : { 'abbrev': 'Vr', 'alias': 'V·REPLACE', 'color' : s:palette.red     },
                \ 'c'    : { 'abbrev': 'C',  'alias': 'COMMAND',   'color' : s:palette.green   },
                \ 'cv'   : { 'abbrev': 'C',  'alias': 'EX',        'color' : s:palette.green   },
                \ 'ce'   : { 'abbrev': 'C',  'alias': 'EX',        'color' : s:palette.green   },
                \ 'r'    : { 'abbrev': 'R',  'alias': 'REPLACE',   'color' : s:palette.red     },
                \ 'rm'   : { 'abbrev': 'Rm', 'alias': 'MORE',      'color' : s:palette.yellow  },
                \ 'r?'   : { 'abbrev': 'R?', 'alias': 'CONFIRM',   'color' : s:palette.yellow  },
                \ '!'    : { 'abbrev': 'Sh', 'alias': 'SHELL',     'color' : s:palette.fg_main },
                \ 't'    : { 'abbrev': 'T',  'alias': 'TERM',      'color' : s:palette.fg_main }
                \ }

    let l:mode = mode()
    call s:highlight('StatusVimMode', l:modes[l:mode].color, s:palette.bg_main, 'bold,inverse')
    return l:modes[l:mode].abbrev
endfunction

function! s:highlight_git_branch_status() abort
    let l:git_icon = ''
    let l:git_dir = expand('%:p:h:S')
    let l:git_cmd = 'git -C ' .. git_dir .. ' status --branch --porcelain=2'
    silent! let l:git_cmd_result = system(l:git_cmd)->split('\n')

    " Line                                     Notes
    " ------------------------------------------------------------
    " # branch.oid <commit> | (initial)        Current commit.
    " # branch.head <branch> | (detached)      Current branch.
    " # branch.upstream <upstream_branch>      If upstream is set.
    " # branch.ab +<ahead> -<behind>           If upstream is set and
    "                                          the commit is present.
    " ------------------------------------------------------------

    if v:shell_error
        call s:highlight('StatusGitBranchStatus', s:palette.fg_main, s:palette.bg_blue_nuanced, 'NONE')
        let b:git_branch_status = ''
    else
        let l:git_branch = l:git_cmd_result->copy()->filter('v:val =~ "^# branch.head"')[0]->split()[2]
        let l:git_status = l:git_cmd_result->copy()->filter('v:val !~ "^# "')

        if l:git_status->empty()
            " clean branch
            let l:git_color = s:palette.green_faint
        else
            " dirty branch
            let l:git_color = s:palette.red_faint
        end

        call s:highlight('StatusGitBranchStatus', l:git_color, s:palette.bg_blue_nuanced, 'NONE')
        let b:git_branch_status = l:git_icon .. ' ' .. l:git_branch
    end
endfunction

function! s:get_file_size() abort
    let l:file = expand('%:p')
    let l:bytes = 0

    if l:file->len()
        let l:bytes = l:file->getfsize()
    else
        " it's a buffer
        let l:bytes = wordcount().bytes
    endif

    if l:bytes == 0 || l:bytes == -1 || l:bytes == -2
        return ''
    end

    const l:_1K = 1024
    const l:_1M = 1024 * l:_1K
    const l:_1G = 1024 * l:_1M
    const l:_1T = 1024 * l:_1G
    const l:_1P = 1024 * l:_1T
    const l:_1E = 1024 * l:_1P

    if l:bytes < l:_1K
        return printf('%dB',   l:bytes)
    elseif l:bytes < l:_1M
        return printf('%.1fK', l:bytes/l:_1K)
    elseif l:bytes < l:_1G
        return printf('%.1fM', l:bytes/l:_1M)
    elseif l:bytes < l:_1T
        return printf('%.1fG', l:bytes/l:_1G)
    elseif l:bytes < l:_1P
        return printf('%.1fT', l:bytes/l:_1T)
    elseif l:bytes < l:_1E
        return printf('%.1fP', l:bytes/l:_1P)
    else " math.maxinteger = 2^63 -1
        return printf('%.1fE', l:bytes/l:_1E)
    end
endfunction

function! DrawStatusLine() abort
    if g:statusline_winid != win_getid()
        return join ([
                    \    '%#StatusFileName#',
                    \    ' ',
                    \    '%<%F',
                    \    '%=',
                    \    ' ',
                    \    '%#StatusPercent#',
                    \    '%P',
                    \    ' '
                    \ ], '')
    else
        return join ([
                    \    '%#StatusVimMode#',
                    \    ' ',
                    \    s:get_vim_mode(),
                    \    ' ',
                    \    '%#StatusBlank#',
                    \    ' ',
                    \    '%#StatusFileName#',
                    \    '%<%F',
                    \    '%#StatusBlank#',
                    \    ' ',
                    \    '%#StatusFileState#',
                    \    '%m%r%h%w%q',
                    \    '%#StatusBlank#',
                    \    ' ',
                    \    '%#StatusGitBranchStatus#',
                    \    '%{b:->get("git_branch_status", "")}',
                    \    '%#StatusBlank#',
                    \    '%=',
                    \    ' ',
                    \    '%#StatusFileSize#',
                    \    s:get_file_size(),
                    \    '%#StatusBlank#',
                    \    ' ',
                    \    '%#StatusFileFormat#',
                    \    ' ',
                    \    '%{&fileformat}',
                    \    ' | ',
                    \    '%#StatusFileEncode#',
                    \    '%{&fileencoding ? &fileencoding : &encoding}',
                    \    ' ',
                    \    '%#StatusBlank#',
                    \    ' ',
                    \    '%#StatusPercent#',
                    \    '%P',
                    \    ' '
                    \ ], '')
    endif
endfunction

call s:set_highlights()
set statusline=%!DrawStatusLine()

augroup status_line | autocmd!
    autocmd WinEnter,BufEnter,BufWritePost * call s:set_highlights()
    autocmd VimResized *  redrawstatus
augroup END

" }}}

" tab line {{{

set tabline=%!DrawTabLine()
function! DrawTabLine() abort
    let l:tabline = ''
    let l:selected_tab_nr = tabpagenr()
    let l:last_tab_nr = tabpagenr('$')

    for i in range(1, l:last_tab_nr)
        " select the highlighting
        if i == selected_tab_nr
            let l:tabline ..= '%#TabLineSel#'
        else
            let l:tabline ..= '%#TabLine#'
        endif

        " set the tab page number (for mouse clicks)
        let l:tabline ..= '%' .. i .. 'T'

        " the label consists of tab # and bufname of active window
        let l:buflist = tabpagebuflist(i)
        let l:winnr = tabpagewinnr(i)
        let l:buf = l:buflist[l:winnr - 1]
        let l:bufname = bufname(l:buf)->fnamemodify(':~')->pathshorten()

        let l:tabline ..= ' ' .. i .. ':' .. l:bufname .. ' '

        " if buffer is modified
        let l:buf_modified = getbufvar(l:buf, '&modified')
        if l:buf_modified | let l:tabline ..= '[+] ' | endif

        if i != l:last_tab_nr &&
                    \ i != l:selected_tab_nr &&
                    \ i + 1 != l:selected_tab_nr
            let l:tabline ..= '|'
        endif
    endfor

    " after the last tab fill with TabLineFill and reset tab page nr
    let l:tabline ..= '%#TabLineFill#%T'

    return l:tabline
endfunction

call s:highlight('TabLineSel',  s:palette.blue,    s:palette.bg_main, 'bold,inverse')
call s:highlight('TabLine',     s:palette.fg_main, s:palette.bg_dim,  'NONE')
call s:highlight('TabLineFill', s:palette.fg_main, s:palette.bg_main, 'NONE')

" }}}

" plugins {{{
let s:package = 'plugged'
let s:package_start_dir = s:vim_home .. '/pack/' .. s:package .. '/start'
let s:package_opt_dir   = s:vim_home .. '/pack/' .. s:package .. '/opt'

" paq:
" {
"    'paq_name': { 'dir': dir, 'url': url }
" }
let s:paqs = {}

" Paq management functions
function! s:paq_init() abort
    call mkdir(s:package_start_dir, 'p')
    call mkdir(s:package_opt_dir,   'p')
endfunction

function! s:paq_add(name, args = {}) abort
    let l:url = 'https://github.com/' .. a:name
    let l:as = a:args->get('as', a:name->split('/')[1])

    if a:args->get('opt', v:false)
        let l:dir = s:package_opt_dir   .. '/' .. l:as
    else
        let l:dir = s:package_start_dir .. '/' .. l:as
    endif

    let s:paqs[l:as] = { 'dir': l:dir->glob(), 'url': l:url }
endfunction

function! s:paq_update() abort
    for paq in s:paqs->items()
        let l:as  = paq[0]
        let l:dir = paq[1].dir
        let l:url = paq[1].url

        " check if it has been git cloned already
        if finddir('.git', l:dir)->empty()
            let l:git_clone_cmd = 'git clone --depth=1 ' .. l:url .. ' ' .. l:dir
            silent! let l:git_cmd_result = system(l:git_clone_cmd)->split('\n')
        else
            let l:git_pull_cmd = 'git -C ' .. l:dir .. ' ' .. 'pull --depth=1'
            silent! let l:git_cmd_result = system(l:git_pull_cmd)->split('\n')
        endif

        echo printf("%17s: %s", l:as, l:git_cmd_result[0])
    endfor
endfunction

function! s:paq_clean() abort
    let l:dirs = []
    for dir in [ s:package_start_dir, s:package_opt_dir ]
        let l:dirs += glob(dir .. '/*', v:true, v:true)
    endfor

    " blend the 2 lists and do a sort
    " remove duplicates from a sorted list
    " the remainder will be ones to be deleted
    let l:dirs = sort(l:dirs + s:paqs->values()->map({ _, val -> val.dir }))

    let l:idx = 0
    let l:len = l:dirs->len()
    while l:idx < l:len
        let l:val = l:dirs[l:idx]
        while (l:idx + 1 < l:len)
            if (l:val != l:dirs[l:idx + 1])
                break
            endif

            let l:dirs[l:idx] = ''
            let l:dirs[l:idx + 1] = ''

            let l:idx += 1
        endwhile

        let l:idx += 1
    endwhile

    if l:dirs->filter('v:val != ""')->empty()
        redraw! | echo 'Package [' .. s:package .. '] is clean.'
    else
        let l:prompt = "WARNING:\nThe following folder(s) will be deleted.\n\n"
                    \ .. l:dirs->join("\n") .. "\n\n"
                    \ .. "Are you sure? "
        if 1 == confirm(l:prompt, "&y\n&n", 2, "Warning")
            for dir in l:dirs
                call delete(dir, 'rf')
            endfor
        endif
    endif
endfunction

" -------
" plugins
" -------
" system plugins

" matchit
packadd! matchit

" netrw
let g:netrw_banner       = 0
let g:netrw_browse_split = 4
let g:netrw_dirhistmax   = 0
let g:netrw_keepdir      = 0
let g:netrw_list_hide    = '\(^\|\s\s\)\zs\.\S\+'
let g:netrw_liststyle    = 3
let g:netrw_winsize      = 29

nnoremap <silent> <F9> <Cmd>Lexplore<CR>

" remap cd to be global
augroup netrw_group | autocmd!
    autocmd filetype netrw
                \ nnoremap <buffer> <silent> <nowait> <LocalLeader>cd
                \ <Cmd>execute 'cd ' .. b:netrw_curdir<CR><Cmd>pwd<CR>
augroup END

" termdebug
let g:termdebug_wide = 1

" personal plugins
call s:paq_add('prabirshrestha/asyncomplete.vim',     {'as': 'asyncomplete'})
call s:paq_add('prabirshrestha/asyncomplete-lsp.vim', {'as': 'asyncomplete-lsp'})
call s:paq_add('jiangmiao/auto-pairs')
call s:paq_add('chrisbra/colorizer',                  {'as': 'colorizer'})
call s:paq_add('tpope/vim-commentary',                {'as': 'commentary'})
call s:paq_add('tpope/vim-eunuch',                    {'as': 'eunuch'})
call s:paq_add('tommcdo/vim-exchange',                {'as': 'exchange'})
call s:paq_add('tpope/vim-fugitive',                  {'as': 'fugitive'})
call s:paq_add('machakann/vim-highlightedyank',       {'as': 'highlighted-yank'})
call s:paq_add('tpope/vim-repeat',                    {'as': 'repeat'})
call s:paq_add('tpope/vim-surround',                  {'as': 'surround'})
call s:paq_add('tpope/vim-unimpaired',                {'as': 'unimpaired'})

" fzf
call s:paq_add('junegunn/fzf.vim', {'as': 'fzf'})
let g:fzf_layout = { 'down': '40%' }
let g:fzf_preview_window = []

nnoremap <Leader>ff <Cmd>Files<CR>
nnoremap <Leader>fo <Cmd>History<CR>
nnoremap <Leader>f: <Cmd>Hisotry:<CR>
nnoremap <Leader>f/ <Cmd>Hisotry/<CR>
nnoremap <Leader>fb <Cmd>Buffers<CR>
nnoremap <Leader>fh <Cmd>Helptags<CR>

" lion
call s:paq_add('tommcdo/vim-lion', {'as': 'lion'})
let g:lion_squeeze_spaces = 1

" lsp
call s:paq_add('prabirshrestha/vim-lsp', {'as': 'lsp'})
let g:lsp_diagnostics_echo_cursor = 1

augroup lsp_clangd | autocmd!
    autocmd User lsp_setup call lsp#register_server({
                \       'name': 'clangd',
                \       'cmd': { server_info->[ 'clangd' ] },
                \       'allowlist': [ 'c', 'cpp', 'objc', 'objcpp' ],
                \ })
augroup END

augroup lsp_install | autocmd!
    " call s:init_lsp_buffer only for languages that has the server registered.
    autocmd User lsp_buffer_enabled call s:init_lsp_buffer()
augroup END

function! s:init_lsp_buffer() abort
    setlocal omnifunc=lsp#complete
    setlocal signcolumn=yes
    if exists('+tagfunc')
        setlocal tagfunc=lsp#tagfunc
    endif

    call s:set_lsp_keymaps()
endfunction

function! s:set_lsp_keymaps() abort
    nnoremap <buffer> gd <Plug>(lsp-definition)
    nnoremap <buffer> gr <Plug>(lsp-references)
    nnoremap <buffer> gi <Plug>(lsp-implementation)
    nnoremap <buffer> gt <Plug>(lsp-type-definition)
    nnoremap <buffer> gR <Plug>(lsp-rename)
    nnoremap <buffer> [g <Plug>(lsp-previous-diagnostic)
    nnoremap <buffer> ]g <Plug>(lsp-next-diagnostic)
    nnoremap <buffer> K  <Plug>(lsp-hover)
endfunction

" rainbow
call s:paq_add('luochen1990/rainbow')
let g:rainbow_active = 1

" sneak
call s:paq_add('justinmk/vim-sneak', {'as': 'sneak'})
let g:sneak#label = 1

noremap <Leader>s <Plug>Sneak_s
noremap <Leader>S <Plug>Sneak_S

noremap f <Plug>Sneak_f
noremap F <Plug>Sneak_F
noremap t <Plug>Sneak_t
noremap T <Plug>Sneak_T

" vinegar
call s:paq_add('tpope/vim-vinegar', {'as': 'vinegar'})
noremap - k^

" define user commands for updating/cleaning the plugins
command! PaqUpdate source $MYVIMRC | call <SID>paq_init() | call <SID>paq_update()
command! PaqClean  source $MYVIMRC | call <SID>paq_init() | call <SID>paq_clean()

nnoremap <silent> <Leader>qu <Cmd>PaqUpdate<CR>
nnoremap <silent> <Leader>qc <Cmd>PaqClean<CR>

" }}}
